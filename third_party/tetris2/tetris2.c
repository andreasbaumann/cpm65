/* Simple Tetris in the terminal, adapted for CP/M-65, */
/* generated by using p2c with tetris.pas for CP/M 2.2 Apple ][ */
/* A.Baumann, 14.12.2024, 0BSD clause */

#include <cpm.h>
#include <ctype.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "lib/screen.h"

#define Delay           100
#define BoardHeight     20
#define BoardWidth      10
#define NofShapes       5

static uint8_t Shapes[NofShapes][4][4] = {
  /* I */
  { { 0, 0, 0, 0 },
    { 1, 1, 1, 1 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* O */
  { { 0, 1, 1, 0 },
    { 0, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* T */
  { { 0, 1, 0, 0 },
    { 1, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* L */
  { { 0, 0, 1, 0 },
    { 1, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* Z */
  { { 1, 1, 0, 0 },
    { 0, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } }
};

uint8_t Board[BoardHeight][BoardWidth];
bool GameOver;
uint8_t CurrentPiece, CurrentRotation;
int8_t PosX, PosY;

static void InitializeBoard(void)
{
  memset(Board, 0, sizeof(uint8_t) * BoardWidth * sizeof(uint8_t) * 10);
}

static void DrawBoard(void)
{
  uint8_t x, y;

  for (y = 1; y <= BoardHeight; y++) {
    for (x = 1; x <= BoardWidth; x++) {
      screen_setcursor(x,y);
      if (Board[y-1][x-1] == 1)
        screen_putchar('#');
      else
        screen_putchar('.');
    }
  }
}


static void DrawPiece(bool Erase)
{
  uint8_t x, y;

  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++) {
      if (Shapes[CurrentPiece][y][x] == 1) {
        screen_setcursor(PosX + x, PosY + y);
        if (Erase)
          screen_putchar('.');
        else
          screen_putchar('#');
      }
    }
  }
}

static bool CanMove(int8_t dx, int8_t dy)
{
  int8_t x, y;

  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++) {
      if (Shapes[CurrentPiece][y][x] == 1) {
        if (PosX + x + dx < 1 || PosX + x + dx > BoardWidth ||
            PosY + y + dy > BoardHeight ||
            Board[PosY + y + dy - 1][PosX + x + dx - 1] == 1)
          return false;
      }
    }
  }
  return true;
}

static void NewPiece(void)
{
  CurrentPiece = (uint8_t)rand() % NofShapes;
  CurrentRotation = 0;
  PosX = BoardWidth / 2 - 2;
  PosY = 1;
  if (!CanMove(0, 0))
    GameOver = true;
}

static void RotatePiece(void)
{
  uint8_t Temp[4][4];
  uint8_t x, y;

  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++)
      Temp[y][x] = Shapes[CurrentPiece][3 - x][y];
  }
  if (!CanMove(0, 0))
    return;
  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++)
      Shapes[CurrentPiece][y][x] = Temp[y][x];
  }
}

static void PlacePiece(void)
{
  uint8_t x, y;

  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++) {
      if (Shapes[CurrentPiece][y][x] == 1)
        Board[PosY + y - 1][PosX + x - 1] = 1;
    }
  }
}

static void ClearLines(void)
{
  uint8_t x, y, ny;
  bool Full;
  bool Redraw = false;

  for (y = BoardHeight; y >= 1; y--) {
    Full = true;
    for (x = 0; x < BoardWidth; x++) {
      if (Board[y-1][x] == 0)
        Full = false;
    }
    if (Full) {
      for (ny = y; ny >= 2; ny--) {
        for (x = 0; x < BoardWidth; x++)
          Board[ny-1][x] = Board[ny-2][x];
      }
      for (x = 0; x < BoardWidth; x++)
        Board[0][x] = 0;
      Redraw = true;
    }
  }
  if (Redraw)
    DrawBoard();
}

static void HandleInput(void)
{
  uint8_t c;

  c = screen_getchar(Delay);
  if (c > 0) {
    c = toupper(c);
    switch (c) {
    case 'A':
      if (CanMove(-1, 0)) {
        DrawPiece(true);
        PosX--;
        DrawPiece(false);
      }
      break;

    case 'D':
      if (CanMove(1, 0)) {
        DrawPiece(true);
        PosX++;
        DrawPiece(false);
      }
      break;

    case 'S':
      if (CanMove(0, 1)) {
        DrawPiece(true);
        PosY++;
        DrawPiece(false);
      }
      break;

    case ' ':
      while (CanMove(0, 1)) {
        DrawPiece(true);
        PosY++;
        DrawPiece(false);
      }
      break;

    case 'W':
      DrawPiece(true);
      RotatePiece();
      DrawPiece(false);
      break;

    case 'Q':
      GameOver = true;
      break;
    }
  }
}

int main(void)
{
  if(!screen_init()) {
    cpm_printstring("No SCREEN driver, exiting\n\r");
    cpm_warmboot();
  }
  screen_clear();
  screen_showcursor(0);

  srand( 21342 );
  InitializeBoard();
  DrawBoard();
  GameOver = false;
  NewPiece();
  while (!GameOver) {
    DrawPiece(false);
    HandleInput();
    if (CanMove(0, 1)) {
      DrawPiece(true);
      PosY++;
      DrawPiece(false);
    } else {
      PlacePiece();
      ClearLines();
      NewPiece();
    }
    if (PosY >= BoardHeight)
      GameOver = true;
  }
  screen_clear();
  printf("Thanks for playing.\n");
  screen_showcursor(1);

  cpm_warmboot();
}
